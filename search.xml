<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>安卓内核编译+驱动编译+打包成boot刷入</title>
      <link href="/posts/27a87966.html"/>
      <url>/posts/27a87966.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓内核驱动编译</title>
      <link href="/posts/4cd61ccd.html"/>
      <url>/posts/4cd61ccd.html</url>
      
        <content type="html"><![CDATA[<p>编译安卓内核驱动，需要对应设备的内核源码，安卓手机的内核源码一般可以在github上面搜索到，如果机型较新，可能没有对应的内核源码，这个时候就只能等设备厂商开放了。github搜索关键词一般为android_kernel_&lt;设备品牌&gt;_&lt;cpu代号或手机代号&gt;。</p><p>下面的例子将使用oneplus 8 的内核源码进行驱动编译。</p><p>内核源码：<a href="https://github.com/ppajda/android_kernel_oneplus_sm8250">https://github.com/ppajda/android_kernel_oneplus_sm8250</a><br />驱动源码: <a href="https://github.com/Poko-Apps/MemKernel">https://github.com/Poko-Apps/MemKernel</a></p><h2 id="1-克隆需要的代码"><a class="markdownIt-Anchor" href="#1-克隆需要的代码"></a> 1. 克隆需要的代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆内核源码</span><br>git clone https://github.com/ppajda/android_kernel_oneplus_sm8250.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆驱动源码</span><br>git clone https://github.com/Poko-Apps/MemKernel.git<br></code></pre></td></tr></table></figure><h2 id="2-配置"><a class="markdownIt-Anchor" href="#2-配置"></a> 2. 配置</h2><p>配置驱动文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入内核源码文件夹</span><br>cd android_kernel_oneplus_sm8250<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里使用 MemKernel 驱动的自动配置，如果是普通驱动，请参见后文</span><br>curl -LSs &quot;https://raw.githubusercontent.com/Poko-Apps/MemKernel/main/kernel/setup.sh&quot; | bash -s M<br></code></pre></td></tr></table></figure><p>配置defconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">调用make distclean,清除原来的配置</span><br>make distclean<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成新的配置文件， xxx_defconfig 为你手机能编译通过的配置文件，一般位于 <span class="hljs-built_in">arch</span>/arm64/config 中</span><br>make ARCH=arm64 xtd_defconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">调整配置文件</span><br>make ARCH=arm64 menuconfig<br></code></pre></td></tr></table></figure><p><img src="/assets/image001.png" alt="" /></p><p>开启内核的LKM支持</p><p><img src="/assets/image0001.png" alt="" /></p><p>进入设备驱动目录</p><p><img src="assets/image.png" alt="" /></p><p>将添加的驱动改为M（按键盘的M键），然后保存配置</p><h2 id="3-编译"><a class="markdownIt-Anchor" href="#3-编译"></a> 3. 编译</h2><p>自制编译驱动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HOME path</span><br>export HOME=path/to/home<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Compiler environment</span><br>export CLANG_PATH=$HOME/clang/bin<br>export PATH=&quot;$CLANG_PATH:$PATH&quot;<br>export CROSS_COMPILE=aarch64-linux-gnu-<br>export CROSS_COMPILE_ARM32=arm-linux-gnueabi-<br><br><br>make ARCH=arm64 CC=clang LD=ld.lld AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip modules<br><br></code></pre></td></tr></table></figure><p><strong>在运行脚本时关闭LTO支持，很重要，不然会编译不成功</strong></p><p><img src="/assets/image3333.png" alt="" /></p><p>编译成功后就能在out/drivers/memkernel 中找到对应的 .ko 可挂载驱动文件了</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓内核 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转录组分析概述</title>
      <link href="/posts/3f4340b4.html"/>
      <url>/posts/3f4340b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>转录组（transcriptome）广义上指某一生理条件下，细胞内所有转录产物的集合，包括信使RNA、核糖体RNA、转运RNA及非编码RNA；狭义上指所有mRNA的集合。转录组测序分析可以分为有参转录组分析和无参转录组分析。有参无参的意思是，有/无参考基因组。</p><h2 id="转录组上游分析"><a class="markdownIt-Anchor" href="#转录组上游分析"></a> 转录组上游分析</h2><p>转录组上游分析一般有3种模式：</p><ul><li>有参转录组上游分析</li><li>有参考基因组无注释文件上游分析或寻找新的转录本</li><li>无参考基因组</li></ul><p><img src="/assets/Pastedimage20231125161646.png" alt="" /><br />DOI: <a href="https://doi.org/10.1186/s13059-016-0881-8">10.1186/s13059-016-0881-8</a></p><h3 id="测序数据及质量控制"><a class="markdownIt-Anchor" href="#测序数据及质量控制"></a> 测序数据及质量控制</h3><p>测序数据主要由fastq格式提供，包含测序片段的序列信息和相应的测序质量打分，每条read由四行描述信息组成：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ST-E00600:</span><span class="hljs-number">42</span>:<span class="hljs-attribute">H3JYTALXX</span>:<span class="hljs-number">1</span>:<span class="hljs-number">1101</span>:<span class="hljs-number">1217</span>:<span class="hljs-number">1000</span> <span class="hljs-number">1</span>:<span class="hljs-attribute">N</span>:<span class="hljs-number">0</span>:TCCGTCTA<br>GGCCAAAAAGGGGGAGTGGGTGGGTAGGGGAGTGCCAGGGCCAAAAAGGGGGAGTGGGTGGGTAGGGGAGTGGGGGTGGGTGGGTATGGGGGACTTTTGGTATAGCATTGAAAATGTAAATGAGCTAAATACCTAATAAAAAATGGAAAA<br>+<br><span class="hljs-attribute">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>:<span class="hljs-attribute">FFFFFFFFFFFFFFFFFFFFFFFFFF</span>:<span class="hljs-attribute">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>:<span class="hljs-attribute">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>:<br></code></pre></td></tr></table></figure><ol><li>第一行以<code>@</code>开头，后面包含测序标识符和描述文字</li><li>第二行为测序片段的序列信息</li><li>第三行以<code>+</code>开头，后面为测序标识符</li><li>第四行为测序片段的质量值。</li></ol><h3 id="测序数据过滤"><a class="markdownIt-Anchor" href="#测序数据过滤"></a> 测序数据过滤</h3><p>使用过滤软件保留高质量的序列数据，去除接头序列，参考过滤标准：</p><ol><li>去除带接头（adapter）的 reads；</li><li>当任一测序read中N含量超过该read碱基数的10%时，去除此paired reads；</li><li>当任一测序read中含有的低质量（Q&lt;=20）碱基数超过该条read碱基数的50%时，去除此paired reads。</li></ol><h3 id="测序错误分布"><a class="markdownIt-Anchor" href="#测序错误分布"></a> 测序错误分布</h3><p>当前RNA-seq测序技术，测序错误率分布存在以下两个特征：</p><ol><li>测序错误率随着测序序列(Sequenced Reads)长度的增加而升高。这是由测序过程中化学试剂的消耗导致的；</li><li>前6个碱基具有较高的测序错误率，此长度恰好为RNA-seq建库过程中反转录所需的随机引物长度。前6个碱基测序错误率较高是因为随机引物和RNA模版的不完全结合</li></ol><h3 id="gc含量分布"><a class="markdownIt-Anchor" href="#gc含量分布"></a> GC含量分布</h3><p>GC含量分布检查用于检测有无 AT、GC 分离现象。由于序列的随机打断和双链互补原则，理论上测序读段在每个位置的 GC 及 AT 含量应分别相等，且在整个测序过程基本稳定不变。但由于反转录使用的是 6 bp 随机引物，因此前几位碱基在核苷酸组成上会有一定偏好性，产生正常波动，随后则趋于稳定。</p><h2 id="转录组下游分析"><a class="markdownIt-Anchor" href="#转录组下游分析"></a> 转录组下游分析</h2><p>进行差异表达基因的筛选，也可将转录本比对到参考序列后进行基因结构方面的分析。</p><p><strong>转录组生物信息分析流程如下图所示：</strong></p><p><img src="/assets/Pastedimage20240301203118.png" alt="" /></p><h3 id="新转录本预测"><a class="markdownIt-Anchor" href="#新转录本预测"></a> 新转录本预测</h3><p>根据比对上基因组的 reads 的位置信息，使用<code>StringTie</code>将 reads 组装成转录本。 StringTie 应用网络流算法和可选的从头组装（denovo）来拼接转录本。拼接得到的转录本再使用 <code>GffCompare</code> 与基因组的注释信息比较，从中发现新转录本或新基因。</p><h3 id="可变剪切鉴定"><a class="markdownIt-Anchor" href="#可变剪切鉴定"></a> 可变剪切鉴定</h3><p>可变剪接(Alternative Splicing, AS)，是大多数真核生物细胞中普遍的一种基因表达方式。真核细胞的基因序列包含内含子(intron)与外显子(exon)，在基因转录成mRNA前体后内含子会被RNA剪接体移除，而外显子则保留于成熟mRNA中。一条未经剪接的RNA，可以具有多种外显子剪接形式，因此使得一个基因在不同时间、不同环境中可以翻译出不同的蛋白质，进而增加其生理状况下系统的复杂性或适应性。转录组数据的可变剪接分析使用<code>rMATS</code>实现</p><h3 id="snpindel检测"><a class="markdownIt-Anchor" href="#snpindel检测"></a> SNP/InDel检测</h3><p>单核苷酸多态性（Single Nucleotide Polymorphism，SNP）指基因组上由单个核苷酸变异形成的遗传标记。SNP 标记具有多态性丰富、分布广、遗传稳定性强等特点，而且可以实现高通量、自动化检测，具有低成本、高效的优点，因而成为研究生物表型与基因型之间关系的重要桥梁。插入/缺失（Insertion-Deletion，InDel）是指在近缘种或同一物种不同个体之间基因组同一位点的序列发生了不同大小核苷酸片段的插入或缺失，即一个序列上某一位点相比同源的另一个序列插入或缺失了一个或多个碱基。InDel 标记因其稳定性好、多态性高、分型系统简单，已广泛应用于动植物群体遗传分析、分子辅助育种等领域。一般而言，SNP 是指变异频率大于 1 % 的单核苷酸变异，InDel 的长度大部分在 50 bp 以内。</p><p>由于部分 mRNA 会经历 RNA 编辑（RNA editing），即转录后的 RNA 在编码区发生碱基的插入、删除或替换，产生多态性的基因表达产物。从比对结果来看，SNP 和单碱基替换的 RNA 编辑结果相同。因此通过转录组测序数据检测到的 SNP 和 InDel 难免含有 RNA 编辑的产物。SNP 和 InDel的检测使用<code>GATK</code>实现，注释使用<code>ANNOVAR</code>实现</p><h3 id="基因功能注释"><a class="markdownIt-Anchor" href="#基因功能注释"></a> 基因功能注释</h3><p>从基因组中提取基因的序列，使用 diamond将新基因与 KEGG、GO、NR、Swiss-Prot、TrEMBL、KOG 数据库序列比对得到注释结果，比对条件为Evalue 1e-5。植物转录因子预测使用iTAK软件，iTAK 整合了两个数据库，PlnTFDB 和 PlantTFDB。动物转录因子鉴定使用动物转录因子数据库animalTFDB</p><p><a href="https://yanzhongsino.github.io/2021/05/17/omics_genome.annotation_function/">基因组注释（三）：基因功能注释 | 生信技工 (yanzhongsino.github.io)</a></p><h3 id="基因表达定量"><a class="markdownIt-Anchor" href="#基因表达定量"></a> 基因表达定量</h3><p>根据比对结果和基因在参考基因组上的位置信息，统计每个基因的reads数量。一个转录本的片段数目与测序数据（或Mapped Data）量、转录本长度、转录本表达水平都有关，为了让片段数目能真实地反映转录本表达水平，需要对样品中的Mapped Reads的数目和转录本长度进行归一化。</p><h3 id="差异表达分析"><a class="markdownIt-Anchor" href="#差异表达分析"></a> 差异表达分析</h3><p>GO功能显著性富集分析，KEGG信号通路富集分析，WCGNA，聚类分析，PCA</p><p>**DESeq2、edgeR 和 limma ** 三大包可以说是做转录组差异分析的金标准，大多数转录组的文章都是用这三个 R 包进行差异分析的。</p><p>首先，做差异分析需要的数据有：<strong>表达矩阵</strong>和<strong>分组信息</strong>。</p><p><strong>DESeq2、edgeR 和 limma 包都建议使用 Counts，也就是原始计数数据作为输入进行分析，最好不要使用 FPKM、TPM 等归一化后的数据</strong></p><p>官方参考教程：<strong><a href="https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html">DESeq2</a></strong>、<strong><a href="https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf">edgeR</a></strong>、<strong><a href="https://www.bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf">limma</a></strong></p><p>参考：<a href="https://github.com/hbctraining/DGE_workshop_salmon_online">DEG-workshop</a></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.jianshu.com/p/687766131808">转录组分析流程</a></li><li><a href="https://zhuanlan.zhihu.com/p/591064168">RNA-seq转录组数据分析丨一套完整的案例流程</a></li><li><a href="https://zhuanlan.zhihu.com/p/653841949">差异分析三巨头 —— DESeq2、edgeR 和 limma 包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基因组结构注释</title>
      <link href="/posts/7393dc5b.html"/>
      <url>/posts/7393dc5b.html</url>
      
        <content type="html"><![CDATA[<p><strong>基因组注释分为结构注释和功能注释。</strong></p><p>结构注释能够帮助我们获取基因组上详细的基因分布和结构信息，是功能注释和进化分析的重要基础。基因结构预测包括预测基因组中的基因位点、开放性阅读框架（ORF）、翻译起始位点和终止位点、内含子和外显子区域、启动子、可变剪切位点以及蛋白质编码序列等等。</p><p>功能注释可以帮助我们进一步获得基因的功能信息，包括预测基因中的模序和结构域、蛋白质的功能和所在的生物学通路等</p><p>基因结构注释流程：</p><p><img src="/assets/image-20240709154230086.png" alt="" /></p><p><strong>注意：在开始基因组结构注释前，最好将所有碱基全部改成大写形式</strong>，因为小写碱基有些软件是识别成soft-masked的形式，影响注释预测，edta的TIR预测和geta软件都有可能报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seqkit <span class="hljs-built_in">seq</span> -u genome.fa &gt; genome.upper.fa<br></code></pre></td></tr></table></figure><h2 id="重复序列注释"><a class="markdownIt-Anchor" href="#重复序列注释"></a> 重复序列注释</h2><p><strong>❗❗❗ 重复序列的注释非常重要，如果跳过这一步，会对基因组结构注释的准确性造成很大影响</strong></p><p>重复序列在基因组中占有非常高的比例，根据分布将重复序列分为串联重复（Tandem repeats）和散布重复（Dispersed repeats）</p><p><img src="/assets/image-20240709165408313.png" alt="" /></p><p>对重复序列的注释一般是做基因组注释的第一步，常用的基因组重复序列注释软件有<code>RepeatMasker</code>, <code>RepeatModeler</code>, <code>EDTA</code></p><p>大部分情况下<code>ReapeatMasker</code>的数据库中<strong>没有待注释物种的近缘种</strong>，此时最好用RepeatModeler等软件进行自我训练，用<strong>denovo预测来构建重复序列数据库</strong>。即使数据库中已有近缘种，有时候<strong>Repbase注释重复区的效果不是很好，也推荐进行自我训练。</strong></p><p>这里首先使用<code>RepeatModeler</code>对基因组重复序列进行自我训练，从头预测重复序列，构建数据库。随后使用<code>RepeatMasker</code>对基因组重复序列进行标注</p><h3 id="repeatmasker-repeatmodeler的安装"><a class="markdownIt-Anchor" href="#repeatmasker-repeatmodeler的安装"></a> <code>RepeatMasker</code>, <code>RepeatModeler</code>的安装</h3><p>这两个软件都不推荐从源码安装，安装依赖多的容易让人怀疑人生。</p><p>这里提供两种安装方式</p><p><code>conda</code>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mamba install bioconda::repeatmasker -c conda-forge<br>mamba install bioconda::repeatmodeler -c conda-forge<br></code></pre></td></tr></table></figure><p>这里推荐指定两个conda chanel, bioconda和conda-forge，提高安装成功率。有很多依赖包在conda-forge里才能找到。这里同样也推荐新建conda环境，用于这两个软件的安装。</p><p><code>mamba</code>是<code>conda</code>的C++语言版本替代，可以大幅提高<code>conda</code>的响应时间。<a href="https://github.com/mamba-org/mamba">mamba-org/mamba: The Fast Cross-Platform Package Manager (github.com)</a></p><p><code>docker</code>安装</p><p>这里使用了由Dfam团队维护的docker镜像进行安装，也可以在github中克隆项目，自己构建镜像。<a href="https://github.com/Dfam-consortium/TETools">Dfam-consortium/TETools: Dfam Transposable Element Tools Docker container. (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull dfam/tetools<br>docker run  --name tetools -v &lt;host path&gt;:&lt;container path&gt; dfam/tetools<br><span class="hljs-comment"># 进入容器执行命令</span><br>docker <span class="hljs-built_in">exec</span> -it tetools bash<br></code></pre></td></tr></table></figure><ul><li>这里使用了<code>-v</code>选项来将宿主目录挂载到容器内，如果需要对<code>RepeatModeler</code>的Libraries进行更改，就可以先将相关目录挂载到容器内，再对容器内的<code>/opt/RepeatMasker/Libraries</code>目录进行修改。</li><li>Dfam团队的官方镜像很大，解压过后更是达到了90GB以上，可以考虑自己从源码构建镜像。</li></ul><h3 id="repeatmodeler的使用"><a class="markdownIt-Anchor" href="#repeatmodeler的使用"></a> <code>RepeatModeler</code>的使用</h3><p>建库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">BuildDatabase -name sample sample.fa<br></code></pre></td></tr></table></figure><p>自我训练</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> RepeatModeler -threads 30 -database sample -LTRStruct 2&gt;&amp;1 &gt; output.log &amp;<br></code></pre></td></tr></table></figure><ul><li>总共跑6轮，前4轮有几分钟到几十分钟的<code>-threads</code>超负荷运行，后两轮每轮会有长达十几个小时的<code>-threads</code>超负荷运行</li><li>自我训练过程需要耗费数天</li><li>如果基因组太大，可能会出现<code>sample.translation</code>文件读取错误的问题，这个时候可以将基因组文件分成几个小文件（大概4GB左右，已测试），对每个小文件的重复序列进行从头预测，然后将结果进行合并。<a href="https://github.com/Dfam-consortium/RepeatModeler/issues/248">Could not open *.translation file for reading! · Issue #248 · Dfam-consortium/RepeatModeler (github.com)</a></li></ul><p>结果文件：</p><ol><li>sample-families.fa （用于<code>RepeatMasker</code>指定lib）</li><li>sample-families.stk（用于上传到Dfam数据库）</li><li>sample-rmod.log（程序运行日志文件）</li></ol><p>使用<code>seqkit</code>对<code>.fa</code>文件中重复的id重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seqkit rename sample.duplicate.name.fa &gt; sample.renamed.fa<br></code></pre></td></tr></table></figure><h3 id="repeatmasker的使用"><a class="markdownIt-Anchor" href="#repeatmasker的使用"></a> <code>RepeatMasker</code>的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> RepeatMasker sample.fa -pa 12 -lib sample-families.fa -poly -html -gff 2&gt;&amp;1 &gt; output.log &amp;<br></code></pre></td></tr></table></figure><ul><li><code>-species</code>选择<code>RepeatMasker</code>数据库中已有的近缘物种</li><li><code>-pa</code>线程数量，用RMBlast引擎会用到4核，即设置-pa 12会用到48线程。</li><li><code>-lib</code>  指定<code>RepeatModeler</code>自我训练的库<code>sample-families.fa</code></li><li><code>-poly</code> 在file.poly中保存多态的polymorphic的简单重复序列，即微卫星重复序列。</li><li><code>-html</code>输出xhtml格式文件</li><li><code>-gff</code>输出gff格式文件</li><li><code>-dir</code> 指定输出文件的目录，默认时当下目录</li></ul><p><strong>⚠️⚠️⚠️注意：<code>RepeatMasker</code>的运行非常占用内存资源，如果内存不够，可以考虑将基因组按照scaffold或chromosome拆分文件，运行结束后再将结果进行合并。</strong></p><p>结果：</p><ul><li>sample.fa.tbl：结果报告，统计了基因组长度，GC含量，重复序列长度及各类重复序列占比等。</li><li>sample.fa.out：将基因组中预测得到的重复序列和参考序列相比的碱基替换频率、插入/删除率，以及重复序列的位置、结构、类型等信息展示出。</li><li>sample.fa.out.gff：sample.fa.out的gff格式。</li><li>sample.fa.out.html：sample.fa.out的网页形式。</li><li>sample.fa.polyout：通过-poly参数，额外将sample.fa.out中的微卫星注释提取出来。微卫星注释是一种Simple_repeat序列，可以通过*.polyout将*.out的微卫星注释删除。有研究者认为微卫星不能算作严格的重复序列类型，还有研究者甚至认为Simple_repeat全都不能算。</li><li><a href="http://sample.fa.cat.ga">sample.fa.cat.ga</a>：记录了基因组序列和数据库中参考重复序列的比对详情，其中“i”和“v”分别代表了碱基转换（transitions）和颠换（transversions），“-”表示该位点存在碱基插入/删除。</li><li>sample.fa.masked：将重复序列屏蔽成N碱基的masked基因组。</li></ul><p>sample.fa.out每一列含义：</p><ul><li>第一列：比对分值，SW score</li><li>第二列：替代率 perc div.</li><li>第三列：碱基缺失百分率</li><li>第四列：在重复序列中碱基缺失百分率</li><li>第五列：query sequence</li><li>第六列：查询序列起始位置</li><li>第七列：查询序列终止位置</li><li>第八列：查询区域中超出比对区域碱基的数- 目，也就是没有比对上的碱基数</li><li>第九列：+/-©</li><li>第十列：比上的重复序列名称，类型命名</li><li>第十一列：比上重复序列的分类，和- repeatmolder 中*.classed 是一样的</li><li>第十二列：比上的在数据库中的起始位置</li><li>第十三列：比上的在数据库中的终止位置</li><li>第十四列：在第十列上超出比对区域碱基的数目，也就是没有比对上的碱基数</li><li>第十五列：比对区域的ID，随机给的</li></ul><h2 id="编码基因注释"><a class="markdownIt-Anchor" href="#编码基因注释"></a> 编码基因注释</h2><p>这里采用<a href="https://github.com/Gaius-Augustus/BRAKER">BRAKER</a>对基因组编码基因进行注释</p><p>BRAKER提供了4种运行模式：</p><ol><li><a href="https://github.com/Gaius-Augustus/BRAKER#braker-with-rna-seq-data">BRAKER with RNA-Seq data</a></li><li><a href="https://github.com/Gaius-Augustus/BRAKER#braker-with-protein-data">BRAKER with protein data</a></li><li><a href="https://github.com/Gaius-Augustus/BRAKER#braker-with-rna-seq-and-protein-data">BRAKER with RNA-Seq and protein data</a></li><li><a href="https://github.com/Gaius-Augustus/BRAKER#braker-with-short-and-long-read-rna-seq-and-protein-data">BRAKER with short and long read RNA-Seq and protein data</a></li></ol><p><a href="https://github.com/Gaius-Augustus/BRAKER#keys-to-successful-gene-prediction">基因成功预测的关键</a>：</p><ol><li>使用高质量的基因组</li><li>使用简单的scaffold (contig, chromosome) 名称</li><li>屏蔽重复序列</li><li>调整运行参数以适应不同的基因结构</li><li>在使用注释之前评估注释结果</li></ol><p>建议docker安装 <a href="https://hub.docker.com/r/teambraker/braker3">teambraker/braker3 - Docker Image | Docker Hub</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull teambraker/braker3<br></code></pre></td></tr></table></figure><p>安装后运行容器shell</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker run --<span class="hljs-keyword">user</span> <span class="hljs-title">1000</span>:<span class="hljs-number">100</span> -v <span class="hljs-tag">&lt;host path&gt;</span>:<span class="hljs-tag">&lt;container path&gt;</span> --rm -it teambraker/braker3:latest bash<br></code></pre></td></tr></table></figure><p>在容器shell中进行编码基因注释</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">nohup braker.pl --threads &lt;int&gt; <span class="hljs-attribute">--genome</span>=&lt;genome&gt; <span class="hljs-attribute">--species</span>=&lt;species name&gt; <span class="hljs-attribute">--prot_seq</span>=&lt;orthologous protein&gt; <span class="hljs-attribute">--bam</span>=&lt;RNA-Seq data&gt;  <span class="hljs-attribute">--workingdir</span>=&lt;work dir&gt; 2&gt;&amp;1 &gt; braker.log &amp;<br></code></pre></td></tr></table></figure><ul><li>这里为第三种运行模式</li><li><code>--bam</code> 参数后必须为<code>.bam</code> 文件，如有多个文件，需要用逗号隔开</li></ul><p>结果：</p><ul><li>braker.aa 从注释中提取的蛋白质序列</li><li>braker.codingseq 从注释中提取的CDS序列</li><li>braker.gtf BRAKER预测的基因组结构文件</li><li>hintsfile.gff 来自RNA-Seq/蛋白数据的外部证据信息</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://www.plob.org/article/4700.html">基因组注释介绍 | Public Library of Bioinformatics (plob.org)</a></li><li><a href="https://liuyujie0136.gitbook.io/sci-tech-notes/bioinformatics/genome-denovo-ann">基因组注释基本流程 | Science and Technology Notes (gitbook.io)</a></li><li><a href="https://yanzhongsino.github.io/2021/08/02/omics_genome.annotation_repeat/#:~:text=%E7%BB%93%E5%90%88RepeatMasker%E5%92%8CEDTA%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E6%9C%80%E7%BB%88%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%B3%A8%E9%87%8A%E3%80%82%201.%20%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%B3%A8%E9%87%8A%20%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E5%8D%A0%E5%9F%BA%E5%9B%A0%E7%BB%84%E9%9D%9E%E5%B8%B8%E9%AB%98%E7%9A%84%E6%AF%94%E4%BE%8B%EF%BC%8C%E5%AF%B9%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%B3%A8%E9%87%8A%E4%B8%80%E8%88%AC%E6%98%AF%E5%81%9A%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%E3%80%82%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E5%9B%A0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6%E6%9C%89RepeatMasker%2C,RepeatModeler%2C%20EDTA%E3%80%82%20%E8%BD%AC%E5%BA%A7%E5%AD%90%28transposable%20elements%2CTE%29%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%86%85%E6%94%B9%E5%8F%98%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E6%AE%B5DNA%E5%BA%8F%E5%88%97%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%94%B1DNA%E5%A4%8D%E5%88%B6%E9%80%A0%E6%88%90%EF%BC%8CTE%E6%98%AF%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E3%80%82">基因组注释（一）：重复序列注释 | 生信技工 (yanzhongsino.github.io)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息 </tag>
            
            <tag> 生信软件使用 </tag>
            
            <tag> 结构注释 </tag>
            
            <tag> 基因组注释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/2f57a694.html"/>
      <url>/posts/2f57a694.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是正则表达式"><a class="markdownIt-Anchor" href="#什么是正则表达式"></a> 什么是正则表达式</h2><p>正则表达式是一组由字母和符号组成的特殊文本，是一种用于匹配和操作文本的强大工具，它可以在文本中查找、替换、提取你想要的文字，也可以用来验证特定的字符组成模式。一个正则表达式一般从左到右匹配主体字符串，常使用缩写的术语“regex”或“regexp”。</p><h2 id="工具和基本语法"><a class="markdownIt-Anchor" href="#工具和基本语法"></a> 工具和基本语法</h2><p>正则表达式一般以<code>\&lt;regex&gt;\&lt;flag&gt;</code>的形式存在，不同软件可能存在差异。<code>&lt;regex&gt;</code>就是我们需要输入的匹配规则，而<code>&lt;flag&gt;</code>则用于标记匹配模式。</p><p><code>&lt;flag&gt;</code>总共有：</p><ul><li><code>g</code>: 全局匹配</li><li><code>i</code>: 忽略大小写</li><li><code>m</code>: 多行匹配</li><li><code>s</code>: 单行匹配</li><li><code>y</code>: 贪婪模式，匹配尽可能多的字符</li></ul><blockquote><p><strong>⚠️⚠️⚠️<code>&lt;flag&gt;</code>标记在不同版本的正则表达式中的差距可能很大，具体请参考<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%89%88%E6%9C%AC">正则表达式版本</a></strong></p></blockquote><h3 id="测试工具"><a class="markdownIt-Anchor" href="#测试工具"></a> 测试工具</h3><p>正则表达式测试工具：</p><p><a href="https://regexr.com/">RegExr: Learn, Build, &amp; Test RegEx</a></p><h3 id="基本规则"><a class="markdownIt-Anchor" href="#基本规则"></a> 基本规则</h3><p><strong>我们利用<code>&lt;regex&gt;</code>来进行文本匹配</strong></p><ul><li><code>at</code>: 匹配文本中的at字符</li><li><code>at.</code>: 匹配文本中at加除换行符外的任意一个字符，<code>.</code>表示匹配除换行符外的任意一个字符</li><li><code>[]</code>: 表示字符集合，<code>[et]</code>表示匹配e或t，<code>at[et]</code>，表示匹配at后跟一个e或一个t的字符，相当于匹配ate或att。<ul><li>方框内的字符还可以用短横线连接表示一个字符范围，如<code>[a-zA-Z]</code>表示匹配所有大小写字母</li><li>方框内还可以使用<code>^</code>号来表示取反，如<code>[^a-z]</code>表示匹配除了小写字母外的所有字符</li></ul></li></ul><p><strong>❗❗❗ 方框内的<code>^</code>号才表示取反，方框外的不表示取反</strong></p><h3 id="预定字符类"><a class="markdownIt-Anchor" href="#预定字符类"></a> 预定字符类</h3><ul><li><code>\d</code>: 表示数字，和<code>[0-9]</code>的作用一致。</li><li><code>\D</code>: 表示非数字</li><li><code>\w</code>: 表示字母，数字或下划线</li><li><code>\W</code>: 表示非字母，数字或下划线</li><li><code>\s</code>: 表示空白字符，如空格，Tab</li><li><code>\S</code>: 表示非空白字符，非空格，Tab</li></ul><h2 id="位置和边界匹配"><a class="markdownIt-Anchor" href="#位置和边界匹配"></a> 位置和边界匹配</h2><ul><li><p><code>^</code>: 匹配每一行的开头，如<code>^a</code>表示匹配以a开头的每一行</p></li><li><p><code>$</code>: 匹配每一行的结尾，如<code>^b</code>表示匹配以b结尾的每一行</p></li><li><p><code>\b</code>: 表示单词的边界，如<code>\bin</code>表示匹配以in开头的字符，而<code>in\b</code>则表示匹配以in结尾的字符</p></li><li><p><code>\B</code>: 表示非单词边界的匹配</p></li></ul><h2 id="量词"><a class="markdownIt-Anchor" href="#量词"></a> 量词</h2><p><code>+</code>: 表示字符重复一次或多次，如<code>at+</code>表示at中t重复一次或多次，会匹配at, att, attt等<br /><code>*</code>: 表示字符重复0次或多次<br /><code>?</code>: 表示字符重复0次或一次<br /><code>&#123;&#125;</code>: 指定的重复次数，如<code>&#123;3&#125;</code>表示重复3次，<code>&#123;3,5&#125;</code>表示重复3到5次，<code>&#123;3,&#125;</code>表示至少重复3次，如果只想匹配重复3次的字符串，可以用<code>&#123;3,&#125;?</code>来表示非贪婪模式</p><h2 id="分组和引用"><a class="markdownIt-Anchor" href="#分组和引用"></a> 分组和引用</h2><ul><li>使用<code>()</code>来就创建分组，如<code>(at)&#123;3,&#125;?</code>表示匹配at整体重复3次的字符串</li><li>使用<code>()</code>创建的分组可以用<code>$</code>+数字来进行捕获，比如<code>$1</code>表示捕获第一个分组的内容</li><li>在匹配字符前加<code>?:</code>表示非捕获分组，这一部分不能被捕获，如<code>(?:\d&#123;1,2&#125;)</code>表示匹配一到两个数字但不捕获它</li></ul><p>如果我们想匹配单词的开头和结尾都是相同字母的字符串，可以用<code>\b([a-z])[a-z]*\1\b</code>来进行匹配，其中<code>\1</code>表示引用前面的第一个分组内容<code>([a-z])</code></p><h2 id="前瞻后顾"><a class="markdownIt-Anchor" href="#前瞻后顾"></a> 前瞻后顾</h2><p>示例内容：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$100</span></span><br><span class="hljs-meta"><span class="hljs-keyword">$200</span></span><br><span class="hljs-meta"><span class="hljs-keyword">$abd</span></span><br><span class="hljs-meta"><span class="hljs-keyword">$deg</span></span><br></code></pre></td></tr></table></figure><ul><li>正向前瞻：仅匹配数字前的$，<code>\$(?=\d+)</code></li><li>负向前瞻：仅匹配非数字前的$，<code>\$(?!\d+)</code></li><li>正向后顾：仅匹配$后面的数字，<code>(?&lt;=\$)\d+</code></li><li>负向后顾：仅匹配非$后面的数字，<code>(?&lt;!\$)\d+</code></li></ul><h2 id="正则表达式版本"><a class="markdownIt-Anchor" href="#正则表达式版本"></a> 正则表达式版本</h2><ul><li>POSIX基本 BRE</li><li>POSIX拓展 ERE</li><li>Perl兼容正则表达式 PCRE</li><li>Python, Javascript等</li></ul><p><strong>不同版本的正则表达式兼容情况不一样，并非所有特性都支持，如果出现匹配不到的情况，也许并非写的正则表达式不正确，而是版本不支持，详细支持情况请参考官方文档</strong></p><ul><li><a href="https://docs.python.org/3/library/re.html">re — Regular expression operations — Python 3.12.4 documentation</a></li><li><a href="https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html">BRE vs ERE (sed, a stream editor) (gnu.org)</a></li><li><a href="https://www.wqlblog.cn/%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e4%b8%8d%e5%90%8c%e9%a3%8e%e6%a0%bc%ef%bc%9abre%e3%80%81ere%e3%80%81pcre/">正则表达式的不同风格：BRE、ERE、PCRE - 吴奇灵的博客 (wqlblog.cn)</a></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 – 语法 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://blog.csdn.net/LLLLQZ/article/details/118278287">正则表达式学习笔记（超级详细！！！）| 有用的小知识-CSDN博客</a></li><li><a href="https://www.bilibili.com/video/BV1fm411C7fq/?share_source=copy_web&amp;vd_source=5962e1119d12ceb673575c266ee9b234">30分钟正则表达式教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> python </tag>
            
            <tag> re模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LaTeX进行数学公式输入</title>
      <link href="/posts/ff7f7414.html"/>
      <url>/posts/ff7f7414.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是latex"><a class="markdownIt-Anchor" href="#什么是latex"></a> 什么是LaTex</h2><p>LaTeX是一个专业的排版系统，擅长处理篇幅较长、结构严谨的文档，并且十分擅长公式表达。它是免费软件，可以在大多数操作系统中安装使用。区别于微软的 Office Word，使用LaTeX并不能「所见即所得」。LaTeX文档是一个以<code>.tex</code>结尾的文本文件，可以使用任何文本编辑器编辑，但对于大多数人而言，使用一个合适的 LaTeX 编辑器会使得编辑的过程容易很多。在编辑的过程中你可以标记文档的结构。完成后你可以进行编译——这意味着将它转化为另一种格式的文档。它支持多种格式，但最常用的是 PDF 文档格式。</p><p>如果需要编写 LaTeX 文档，你需要安装一个「发行版」，常用的发行版有 <a href="http://tug.org/texlive/">TeX Live</a>、<a href="https://miktex.org/">MikTeX</a> 和适用于 macOS 用户的 MacTeX（实际上是 TeX Live 的 macOS 版本），至于 <a href="http://www.ctex.org/">CTeX</a> 则现在不推荐使用。TeX Live 和 MacTeX 带有几乎所有的 LaTeX 宏包；而 MikTeX 只带有少量必须的宏包，其他宏包将在需要时安装。</p><p><strong>这里，将介绍使用LaTeX进行数学公式的编辑，你可以在各种支持LaTeX的软件中来方便的进行数学公式的编辑。</strong></p><ul><li>Office Word</li><li>WPS 文字</li><li>网页（使用MathJax库等）</li></ul><h2 id="用latex编写数学公式"><a class="markdownIt-Anchor" href="#用latex编写数学公式"></a> 用LaTeX编写数学公式</h2><p>使用LaTeX的数学模式来对公式进行排版</p><h3 id="插入公式"><a class="markdownIt-Anchor" href="#插入公式"></a> 插入公式</h3><p><strong>⚠️⚠️⚠️这里仅介绍其它软件中也能使用的规则，其它高级特性请参考相关的LaTeX文档</strong></p><ol><li>行内公式：使用一对<code>$</code>来启用数学模式，用于撰写行内数学公式，例如 <code>$1+2=3$</code> 的生成效果是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1+2=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</li><li>行间公式：可以使用 <code>$$...$$</code>。例如，<code>$$1+2=3$$</code> 的生产效果为</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1+2=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></span></p><h3 id="数学符号"><a class="markdownIt-Anchor" href="#数学符号"></a> 数学符号</h3><blockquote><p>这里只是数学符号使用的入门教程，LaTeX Wikibook 的<a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">数学符号章节</a>是另一个更好更完整的教程。如果想要了解更多关于数学符号的内容请移步。</p></blockquote><h4 id="上标和下标"><a class="markdownIt-Anchor" href="#上标和下标"></a> 上标和下标</h4><p>上标（Powers）使用 <code>^</code> 来表示，比如 <code>$n^2$</code> 生成的效果为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。</p><p>下标（Indices）使用 <code>_</code> 表示，比如 <code>$2_a$</code> 生成的效果为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mn>2</mn><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">2_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>如果上标或下标的内容包含多个字符，请使用花括号包裹起来。比如 <code>$b_&#123;a-2&#125;$</code> 的效果为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mrow><mi>a</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">b_{a-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p><h4 id="分数"><a class="markdownIt-Anchor" href="#分数"></a> 分数</h4><p>分数使用 <code>\frac&#123;numerator&#125;&#123;denominator&#125;</code> 命令插入。比如 <code>$$\frac&#123;a&#125;&#123;3&#125;$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>a</mi><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>分数可以嵌套。比如 <code>$$\frac&#123;y&#125;&#123;\frac&#123;3&#125;&#123;x&#125;+b&#125;$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>y</mi><mrow><mfrac><mn>3</mn><mi>x</mi></mfrac><mo>+</mo><mi>b</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{y}{\frac{3}{x}+b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.187668em;vertical-align:-1.080108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.2648919999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.080108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="根号"><a class="markdownIt-Anchor" href="#根号"></a> 根号</h4><p>我们使用 <code>\sqrt&#123;...&#125;</code> 命令插入根号。省略号的内容由被开根的内容替代。如果需要添加开根的次数，使用方括号括起来即可。例如 <code>$$\sqrt&#123;y^2&#125;$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msqrt><msup><mi>y</mi><mn>2</mn></msup></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.23329099999999992em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.006709em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9667090000000003em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23329099999999992em;"><span></span></span></span></span></span></span></span></span></span></p><p>而 <code>$$\sqrt[x]&#123;y^2&#125;$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mroot><msup><mi>y</mi><mn>2</mn></msup><mi>x</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt[x]{y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.23329099999999992em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6793308000000001em;"><span style="top:-2.9640508em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.006709em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9667090000000003em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23329099999999992em;"><span></span></span></span></span></span></span></span></span></span></p><h4 id="求和与积分"><a class="markdownIt-Anchor" href="#求和与积分"></a> 求和与积分</h4><p>使用 <code>\sum</code> 和 <code>\int</code> 来插入求和式与积分式。对于两种符号，上限使用 <code>^</code> 来表示，而下限使用 <code>_</code> 表示。如<code>$$\sum_&#123;x=1&#125;^5 y^z$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><mn>5</mn></munderover><msup><mi>y</mi><mi>z</mi></msup></mrow><annotation encoding="application/x-tex">\sum_{x=1}^5 y^z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.068226em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span></span></p><p>而 <code>$$\int_a^b f(x)$$</code> 的生成效果为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\int_a^b f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><h4 id="希腊字母"><a class="markdownIt-Anchor" href="#希腊字母"></a> 希腊字母</h4><p>我们可以使用反斜杠加希腊字母的名称来表示一个希腊字母。名称的首字母的大小写决定希腊字母的形态。例如</p><ul><li><code>$\alpha$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></li><li><code>$\beta$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li><code>$\delta, \Delta$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\delta, \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span></span></span></span></li><li><code>$\pi, \Pi$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo separator="true">,</mo><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\pi, \Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Π</span></span></span></span></li><li><code>$\sigma, \Sigma$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\sigma, \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span></span></span></span></li><li><code>$\phi, \Phi, \varphi$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo separator="true">,</mo><mi mathvariant="normal">Φ</mi><mo separator="true">,</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\phi, \Phi, \varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">φ</span></span></span></span></li><li><code>$\psi, \Psi$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo separator="true">,</mo><mi mathvariant="normal">Ψ</mi></mrow><annotation encoding="application/x-tex">\psi, \Psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Ψ</span></span></span></span></li><li><code>$\omega, \Omega$</code>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo separator="true">,</mo><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\omega, \Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Ω</span></span></span></span></li></ul><h4 id="在数学公式中输入空格"><a class="markdownIt-Anchor" href="#在数学公式中输入空格"></a> 在数学公式中输入空格</h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">符号</th><th style="text-align:center">显示</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">两个quad空格</td><td style="text-align:center"><code>$a\qquad b$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="2em"/><mi>b</mi></mrow><annotation encoding="application/x-tex">a\qquad b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">b</span></span></span></span></td><td style="text-align:center">两个m的宽度</td></tr><tr><td style="text-align:center">quad空格</td><td style="text-align:center"><code>$a\quad b$ </code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="1em"/><mi>b</mi></mrow><annotation encoding="application/x-tex">a\quad b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">b</span></span></span></span></td><td style="text-align:center">一个m的宽度</td></tr><tr><td style="text-align:center">大空格</td><td style="text-align:center"><code>$a\ b$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext> </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\ b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace"> </span><span class="mord mathnormal">b</span></span></span></span></td><td style="text-align:center">1/3m宽度</td></tr><tr><td style="text-align:center">中等空格</td><td style="text-align:center"><code>$a\;b$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext>  </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span></span></span></span></td><td style="text-align:center">2/7m宽度</td></tr><tr><td style="text-align:center">紧凑</td><td style="text-align:center"><code>$a b$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span></span></span></span></td><td style="text-align:center">缩紧1/6m的宽度</td></tr></tbody></table><h2 id="在线latex公式编辑器"><a class="markdownIt-Anchor" href="#在线latex公式编辑器"></a> 在线LaTex公式编辑器</h2><ul><li><a href="https://www.latexlive.com/##">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a></li><li><a href="https://latexeasy.com/">LatexEasy | 在线Latex数学公式编辑和渲染</a></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://oi-wiki.org/tools/latex/#%E5%85%AC%E5%BC%8F">LaTeX 入门 - OI Wiki (oi-wiki.org)</a></li><li><a href="https://blog.csdn.net/Richard__Ting/article/details/81211248">Latex数学公式-空格插入-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差异表达分析</title>
      <link href="/posts/94b5d431.html"/>
      <url>/posts/94b5d431.html</url>
      
        <content type="html"><![CDATA[<h2 id="差异分析三巨头-deseq2-edger-limma"><a class="markdownIt-Anchor" href="#差异分析三巨头-deseq2-edger-limma"></a> 差异分析三巨头 DESeq2、edgeR、limma</h2><p>DESeq2、edgeR、limma是转录组差异分析的金标准，大多数转录组的文章和公司都是使用这三个R包做转录组的差异基因分析。</p><p>做差异基因表达分析需要的数据有：<strong>表达矩阵、分组信息</strong></p><ol><li><strong>表达矩阵</strong>：即上游分析得到的每个基因在每个样本中的reads数，这里所使用的差异分析包都要求原始reads数的格式输入。</li><li><strong>分组信息</strong>：即一个实验设计矩阵，包含每一个测序样本属于哪一个实验组或者对照组。</li></ol><blockquote><p>如果想要实现<strong>每个组之间的差异比较</strong>（相当于比较两个组之间哪些基因的表达存在差异，并求得这种差异的统计显著性），则还需要设置比较矩阵，具体设计方法可以参考每个包的说明文档。一般来说如果不设置的话，默认输出中不包含每个组的多重比较结果。</p></blockquote><h2 id="包简介"><a class="markdownIt-Anchor" href="#包简介"></a> 包简介</h2><p>对于有生物学重复的样品，使用DESeq2进行样品组间的差异表达分析，获得两个生物学条件之间的差异表达基因集；对于无生物学重复我们使用edgeR。这里只是一般的使用状态，没有绝对性，比如，edgeR在有生物学重复的情况下也能使用，只是在识别差异基因的能力和出现假阳性结果等方面两个包存在不同而已。上文提到的三个R包做差异分析都要求输入基因的未经过标准化的 reads 计数数据，而不能是 RPKM、FPKM 等经过标准化的数据。</p><p>差异分析之后，还需要用 Benjamini-Hochberg 方法对假设检验概率（P value）进行多重假设检验校正，得到错误发现率（False Discovery Rate，FDR）。差异基因的筛选条件为 |log2Fold Change| &gt;= 1（建议值，可根据实际情况进行调整），且 FDR &lt; 0.05</p><h3 id="deseq2"><a class="markdownIt-Anchor" href="#deseq2"></a> DESeq2</h3><p>DESeq2 基于负二项分布模型，考虑了基因表达数据的离散性和变异性，以及库大小差异对差异分析的影响。DESeq2 通过正态化转换和归一化来减少样本间的技术变异，然后估计基因表达的离散性。它使用负二项分布模型来鉴定差异表达基因，并校正多重检验问题。DESeq2 适用于小样本 RNA 测序数据，特别是在样本数较少的情况下表现较好，能够有效地处理样本间的差异、技术性噪音和批次效应。</p><h3 id="edger"><a class="markdownIt-Anchor" href="#edger"></a> edgeR</h3><p>edgeR 与 DESeq2类似，edgeR 也考虑了数据的离散性。它使用负二项分布模型和不同的归一化方法，如 TMM（Trimmed Mean of M values），来处理样本之间的技术变异。edgeR 使用一个假设检验框架来鉴定差异表达基因，并采用了类似于 Benjamini-Hochberg 方法的多重检验校正。edgeR 在样本较多的情况下表现较好，适用于中等规模的 RNA 测序数据，具有较高的灵敏度和精确度。使用 edgeR 时注意选择合适的分析算法，<strong>官方建议 bulk RNA-seq 选择 quasi-likelihood(QL) F-test tests，scRNA-seq 或是没有重复样品的数据选用 likelihood ratio test</strong>。</p><h3 id="limma"><a class="markdownIt-Anchor" href="#limma"></a> limma</h3><p><strong>DESeq2和edgeR都由limma二次开发而来</strong></p><p>limma 最初是针对基因芯片数据开发的，但后来也被应用于 RNA 测序数据。limma 基于线性模型，使用加权最小二乘法来估计基因表达的差异，并通过贝叶斯方法来校正多重检验问题。limma 在处理大规模数据时表现出色，适用于高通量数据分析，如芯片和大规模RNA测序数据，能够很好地控制假阳性率。</p><p>limma 适用于各种类型的高通量数据，包括芯片数据和 RNA-seq。它要求每个基因的表达值，可以是原始计数也可以是已经归一化的表达值。limma 进行差异分析有两种方法 ：limma-trend 和 voom。在样本测序深度相差不大时两种方法差距不大，而测序深度相差大时 voom 更有优势，因此我们一般都选择 voom 的方法进行差异分析</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>limma 包做差异分析要求数据满足正态分布或近似正态分布，如基因芯片、TPM 格式的高通量测序数据。</li><li>通常认为 Counts 数据不符合正态分布而服从泊松分布。所以对于 Counts 数据来说，用 limma 包进行差异分析，误差较大。</li><li>edgeR 差异分析速度快，得到的基因数目比较多，假阳性高（实际不差异，结果差异）；DESeq2 差异分析速度慢，得到的基因数目比较少，假阴性高（实际差异，结果不差异）。</li><li>DESeq2 更关注在小样本条件下的差异分析，提供了一些特有的统计模型和方法。edgeR 强调对技术性噪音和样本之间的变异性进行建模，特别适用于样本数量较大的数据集。limma 则是一种通用的差异分析方法，适用于各种高通量表达数据，不仅适用于 RNA-seq 数据，也适用于其他类型的表达数据，如芯片数据。</li></ol><h2 id="设计对比矩阵"><a class="markdownIt-Anchor" href="#设计对比矩阵"></a> 设计对比矩阵</h2><p><strong>DESeq2</strong></p><p>在使用<code>DESeq()</code>函数计算差异基因过后，可以使用<code>resultsNames()</code>函数查看默认对比组别，这里默认使用第一个组来做对照组，组别之间的差异基因都是跟对照组来比的。如果需要自定义各个组别之间的对比，或者组别为时间序列等其他特殊情况的话，则需要自己设计对比矩阵，可以参考<a href="https://github.com/tavareshugo/tutorial_DESeq2_contrasts">tavareshugo/tutorial_DESeq2_contrasts (github.com)</a>这篇文章。注意，<strong>DESeq2对直接的所有组别两两对比并不友好，如果要使用，建议用edgeR包。</strong></p><p><strong>edgeR</strong></p><p>在使用<code>glmQLFTest()</code>函数计算差异基因时，可以指定<code>contrast</code>参数，该参数接受一个<code>makeContrasts()</code>，该函数有两个参数<code>contrasts</code>和<code>levels</code>，<code>contrasts</code>描述了组别的对比关系，<code>levels</code>描述了不同的组别。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#A, B, C 三组分别两两比较</span><br>makeContrasts<span class="hljs-punctuation">(</span>B<span class="hljs-operator">-</span>A<span class="hljs-punctuation">,</span>C<span class="hljs-operator">-</span>B<span class="hljs-punctuation">,</span>C<span class="hljs-operator">-</span>A<span class="hljs-punctuation">,</span>levels<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;B&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;C&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#A, B, C 三组满足更复杂的函数关系式</span><br>makeContrasts<span class="hljs-punctuation">(</span>contrasts<span class="hljs-operator">=</span><span class="hljs-string">&quot;A(B+C)/2&quot;</span><span class="hljs-punctuation">,</span>levels<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;A&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;B&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;C&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>更详细的对比设计参考<a href="https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/designmatrices.html">A guide to creating design matrices for gene expression experiments (bioconductor.org)</a></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/653841949">看完还不会来揍我 | 差异分析三巨头 —— DESeq2、edgeR 和 limma 包 | 附完整代码 + 注释 - 知乎 (zhihu.com)</a></li><li><a href="https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow_CHN.html">使用limma、Glimma和edgeR，RNA-seq数据分析易如反掌 (bioconductor.org)</a></li><li><a href="https://f1000research.com/articles/5-1438/v2">From reads to genes to pathways: differential… | F1000Research</a></li><li><a href="https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#contrasts">Analyzing RNA-seq data with DESeq2 (bioconductor.org)</a></li><li><a href="https://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#differential-expression-analysis">RNA-seq workflow: gene-level exploratory analysis and differential expression (bioconductor.org)</a></li><li><a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02648-4">Exaggerated false positives by popular differential expression methods when analyzing human population samples | Genome Biology | Full Text (biomedcentral.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息 </tag>
            
            <tag> 生信软件使用 </tag>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastp软件的使用</title>
      <link href="/posts/f2223f63.html"/>
      <url>/posts/f2223f63.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>fastp: A tool designed to provide fast all-in-one preprocessing for FastQ files. This tool is developed in C++ with multithreading supported to afford high performance.</p></blockquote><p><a href="https://github.com/OpenGene/fastp">fastp</a>，它可以仅仅扫描FASTQ文件一次，就完成比FASTQC + cutadapt + Trimmomatic 这三个软件加起来的功能还多很多的功能，而且速度上比仅仅使用Trimmomatic一个软件还要快3倍左右，因为它使用C++开发，处处使用了高效算法，而且完美支持多线程！</p><h2 id="fastp过滤测序序列"><a class="markdownIt-Anchor" href="#fastp过滤测序序列"></a> fastp过滤测序序列</h2><h3 id="过滤"><a class="markdownIt-Anchor" href="#过滤"></a> 过滤</h3><p>fastp可以对低质量序列，较多N的序列，该功能默认是启用的，但可以使用-Q参数关闭。使用-q参数来指定合格的phred质量值，比如-q 15表示质量值大于等于Q15的即为合格，然后使用-u参数来指定最多可以有多少百分比的质量不合格碱基。比如-q 15 -u 40表示一个read最多只能有40%的碱基的质量值低于Q15，否则会被扔掉。使用-n可以限定一个read中最多能有多少个N。</p><p>fastp还默认启用了read长度过滤，但可以使用-L参数关闭。使用-l参数指定最低要求一个read有多长，比如-l 30表示低于30个碱基的read会被扔掉。这个功能可以用于实现常用的discard模式，以保证所有输出的序列都一样长。</p><p>在fastp的HTML报告中，最头上的Summary表格很清楚地显示了过滤的统计信息，如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-6920178b4b210ff1e37089ff8e1b289d_720w.webp" alt="" /></p><h3 id="接头处理"><a class="markdownIt-Anchor" href="#接头处理"></a> 接头处理</h3><p>接头（adapter）污染的处理是FASTQ文件预处理中很重要的一步。fastp默认启用了接头处理，但是可以使用-A命令来关掉。fastp可以自动化地查找接头序列并进行剪裁，也就是说你可以不输入任何的接头序列，fastp全自动搞定了！对于SE数据，你还是可以-a参数来输入你的接头，而对于PE数据则完全没有必要，fastp基于PE数据的overlap分析可以更准确地查找接头，去得更干净，而且对于一些接头本身就有碱基不匹配情况处理得更好。fastp对于接头去除会有一个汇总的报告，如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-202f214ad93c99a305f6b3510ddf3f78_720w.webp" alt="" /></p><h3 id="滑窗质量剪裁"><a class="markdownIt-Anchor" href="#滑窗质量剪裁"></a> 滑窗质量剪裁</h3><p>很多时候，一个read的低质量序列都是集中在read的末端，也有少部分是在read的开头。fastp支持像Trimmomatic那样对滑动窗口中的碱基计算平均质量值，然后将不符合的滑窗直接剪裁掉。使用-5参数开启在5’端，也就是read的开头的剪裁，使用-3参数开启在3’端，也就是read的末尾的剪裁。使用-W参数指定滑动窗大小，默认是4，使用-M参数指定要求的平均质量值，默认是20，也就是Q20。</p><h3 id="pe数据的碱基校正"><a class="markdownIt-Anchor" href="#pe数据的碱基校正"></a> PE数据的碱基校正</h3><p>fastp支持对PE数据的每一对read进行分析，查找它们的overlap区间，然后对于overlap区间中不一致的碱基，如果发现其中一个质量非常高，而另一个非常低，则可以将非常低质量的碱基改为相应的非常高质量值的碱基值，如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-78e31fe48bbdc53f5c1a1427b6170a53_720w.webp" alt="" /></p><p>上图中所示的标红的T碱基是低质量序列，和高质量的A不匹配，它会被校正为A。该校正功能默认没有开启使用-c参数可以启用，对于一些对噪声容忍度低的应用，比如液体活检，建议开启。</p><h3 id="全局剪裁"><a class="markdownIt-Anchor" href="#全局剪裁"></a> 全局剪裁</h3><p>fastp可以对所有read在头部和尾部进行统一剪裁，该功能在去除一些测序质量不好的cycle比较有用，比如151*2的PE测序中，最后一个cycle通常质量是非常低的，需要剪裁掉。使用-f和-t分别指定read1的头部和尾部的剪裁，使用-F和-T分别指定read2的头部和尾部的剪裁。</p><h3 id="polyg剪裁"><a class="markdownIt-Anchor" href="#polyg剪裁"></a> polyG剪裁</h3><p>对于两色发光法的Illumina设备（NextSeq / NovaSeq），因为在没有光信号情况下base calling的结果会返回G，所以在序列的尾端可能会出现较多的polyG，需要被去除。fastp会自动化地识别NextSeq / NovaSeq的数据，然后进行polyG识别和剪裁。如果你想强制开启该功能，可以指定-g参数，如果想强制关闭该功能，则可以指定-G参数。</p><h3 id="分子标签umi处理"><a class="markdownIt-Anchor" href="#分子标签umi处理"></a> 分子标签UMI处理</h3><p>UMI在处理ctDNA类似的超低频突变检测应用中是十分有用的，为了更好地对带UMI的FASTQ文件进行预处理，fastp也很好地支持了UMI预处理功能。该功能默认没有启用，需要使用-U参数开启，另外需要使用–umi_loc来指定UMI所在的位置，它可以是（index1、 index2、 read1、 read2、 per_index、 per_read ）中的一种，分别表示UMI是在index位置上，还是在插入片段中。如果指定了是在插入序列中，还需要使用 --umi_len 参数来指定UMI所占的碱基长度。</p><h3 id="输出文件切分"><a class="markdownIt-Anchor" href="#输出文件切分"></a> 输出文件切分</h3><p>很多时候我们需要对输出的FASTQ进行切分，分成大小均匀的多个文件，这样可以使用比对软件并行地比对，提高并行处理的速度。fastp软件也提供了相应的功能，并且支持了两种模式，分别是使用参数-s指定切分后文件的个数，或者使用-S参数指定每个切分后文件的行数。</p><h2 id="质控报告解读"><a class="markdownIt-Anchor" href="#质控报告解读"></a> 质控报告解读</h2><p>接下来，我们再看一下如何理解fastp生成的质控报告。fastp的报告在单一文件中同时包含了过滤前和过滤后的统计结果，如果是PE数据，则同时包含了read1和read2的统计结果。之前我们已经说过了，fastp会生成HTML的报告和JSON格式的报告。HTML报告的默认文件名是fastp.html，但是可以通过-h参数修改，JSON报告的默认文件名是fastp.json，但是可以通过-j参数修改。而且fastp报告还有一个标题，默认是fastp report，这个也可以通过-R参数修改为你想要的标题。JSON格式的报告是优化过的，人机皆可读，适合进阶的用户使用程序解析，而这里我们重点关注HTML格式的报告。</p><h3 id="质量分布曲线图"><a class="markdownIt-Anchor" href="#质量分布曲线图"></a> 质量分布曲线图</h3><p>我们第一关注的当然是质量，所以fastp提供了质量分布曲线，即每一个cycle的平均质量值，而且fastp同时提供了A/T/C/G四种不同碱基的平均质量，以及总的平均质量，如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-ee5358c3a2a93af49171459278aa751e_720w.webp" alt="" /></p><p>从上图我们可以看到，一共有5条曲线，分别是A/T/C/G和mean。而且HTML报告中的每一个项目和分项目都是可以点击进行隐藏和展开的。</p><h3 id="碱基含量分布曲线"><a class="markdownIt-Anchor" href="#碱基含量分布曲线"></a> 碱基含量分布曲线</h3><p>和质量分布曲线类似，碱基含量分布曲线也是按照每一个cycle来的，显示了每一个位置的碱基含量。如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-c2ca5f1b36bf7c9010d43773dffaf66d_720w.webp" alt="" /></p><p><img src="https://pic2.zhimg.com/80/v2-4d30aaf1dfe395d89d36d9ae5c3e135d_720w.webp" alt="" /></p><p>从图中可以看到，fastp同时显示了A/T/C/G/N/GC<br />的每一个位置的比例和总的比例。而且如果你觉得头部那里比较乱看不清的话，可以用鼠标拉一个框，它就放大了。</p><h3 id="kmer统计表格"><a class="markdownIt-Anchor" href="#kmer统计表格"></a> KMER统计表格</h3><p>fastp对5个碱基长度的所有组合的出现次数进行了统计，然后把它放在了一张表格中，表格的每一个元素为深背景白字，背景越深，则表示重复次数越多。这样，一眼望去，就可以发现有哪一些异常的信息。</p><p><img src="https://pic3.zhimg.com/80/v2-a69e014cd516d44ac2bb0d3cb8d6d67e_720w.webp" alt="" /></p><p>从上面的KMER表格中，我们可以发现，GGGGG的颜色特别深，从鼠标移上去之后显示的信息中我们可以发现它的出现次数是平均次数的12.8倍，这是不正常的，因为GGGGG的正常倍数应该在1倍左右。幸好我们有fastp，它可以过滤掉这种polyG，让数值较多地回归正常。</p><h3 id="过表达序列overrepresented-sequence"><a class="markdownIt-Anchor" href="#过表达序列overrepresented-sequence"></a> 过表达序列(overrepresented sequence)</h3><p>fastp的最新版本（v0.12）提供了overrepresetned<br />sequence的分析，而且不但提供了这些overrepresented sequence的序列个数和占比，还提供了他们在测序cycles中的分布情况，这有利于分析各种问题。具体示例如下图所示：</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/33601691">fastp: 一款超快速全功能的FASTQ文件自动化质控+过滤+校正+预处理软件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息 </tag>
            
            <tag> 生信软件使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
